package edwards25519

import "math"

// BasePointOrder is the number of points in the subgroup generated by the base point.
var BasePointOrder = [32]byte{237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16}

var extendedBaseEl = ExtendedGroupElement{
	FieldElement{25485296, 5318399, 8791791, -8299916, -14349720, 6939349, -3324311, -7717049, 7287234, -6577708},
	FieldElement{-758052, -1832720, 13046421, -4857925, 6576754, 14371947, -13139572, 6845540, -2198883, -4003719},
	FieldElement{-947565, 6097708, -469190, 10704810, -8556274, -15589498, -16424464, -16608899, 14028613, -5004649},
	FieldElement{6966464, -2456167, 7033433, 6781840, 28785542, 12262365, -2659449, 13959020, -21013759, -5262166},
}

// BaseBytes can be used to hash the base point if necessary
var BaseBytes [32]byte = func() [32]byte {
	bb := [32]byte{}
	extendedBaseEl.ToBytes(&bb)
	return bb
}()

// GeAdd sets r = a+b. r may overlaop with a and b.
func GeAdd(r, a, b *ExtendedGroupElement) {
	var bca CachedGroupElement
	b.ToCached(&bca)
	var rc CompletedGroupElement
	geAdd(&rc, a, &bca)
	rc.ToExtended(r)
}

func ExtendedGroupElementCopy(t, u *ExtendedGroupElement) {
	FeCopy(&t.X, &u.X)
	FeCopy(&t.Y, &u.Y)
	FeCopy(&t.Z, &u.Z)
	FeCopy(&t.T, &u.T)
}

func ExtendedGroupElementCMove(t, u *ExtendedGroupElement, b int32) {
	FeCMove(&t.X, &u.X, b)
	FeCMove(&t.Y, &u.Y, b)
	FeCMove(&t.Z, &u.Z, b)
	FeCMove(&t.T, &u.T, b)
}

// GeScalarMult sets r = a*A
// where a = a[0]+256*a[1]+...+256^31 a[31].
func GeScalarMult(r *ExtendedGroupElement, a *[32]byte, A *ExtendedGroupElement) {
	var p, q ExtendedGroupElement
	q.Zero()
	ExtendedGroupElementCopy(&p, A)
	for i := uint(0); i < 256; i++ {
		bit := int32(a[i>>3]>>(i&7)) & 1
		var t ExtendedGroupElement
		GeAdd(&t, &q, &p)
		ExtendedGroupElementCMove(&q, &t, bit)
		GeDouble(&p, &p)
	}
	ExtendedGroupElementCopy(r, &q)
}

func GeDouble(r, p *ExtendedGroupElement) {
	var q ProjectiveGroupElement
	p.ToProjective(&q)
	var rco CompletedGroupElement
	q.Double(&rco)
	rco.ToExtended(r)
}

// FromBytesBaseGroup unmarshals an elliptic curve point returns true iff the
// point point is in the order l subgroup generated by the base point. This
// implementation is based on
// https://www.iacr.org/archive/pkc2003/25670211/25670211.pdf Definition 1.
// Validation of an elliptic curve public key P ensures that P is a point of
// order BasePointOrder in E.
func (p *ExtendedGroupElement) FromBytesBaseGroup(s *[32]byte) bool {

	// condition 1: P != infinity
	if *s == [32]byte{1} {
		return false
	}

	// condition 3 is implied by successful point decompression
	if !p.FromBytes(s) {
		return false
	}
	// condition 2: ToBytes produces canonical encodings, check against that
	var sCheck [32]byte
	p.ToBytes(&sCheck)
	if sCheck != *s {
		return false
	}

	// condition 4: order * P == infinity
	var out ExtendedGroupElement
	GeScalarMult(&out, &BasePointOrder, p)
	out.ToBytes(&sCheck)
	if sCheck != [32]byte{1} {
		return false
	}

	// an array of all zeros would not result from any randomly generated point
	// and might easily be caused by bugs in ToBytes or FromBytes
	if *s == [32]byte{} {
		return false
	}
	return true
}

// Input:
//   s[0]+256*s[1]+...+256^63*s[63] = s
//   s <= l
//
// Output:
//   s[0]+256*s[1]+...+256^31*s[31] = l - s
//   where l = 2^252 + 27742317777372353535851937790883648493.
func ScNeg(r, s *[32]byte) {
	l := [32]byte{237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16}
	var carry int32
	for i := 0; i < 32; i++ {
		carry = carry + int32(l[i]) - int32(s[i])
		negative := carry & math.MinInt32 // extract the sign bit (min=0b100...)
		negative |= negative >> 16
		negative |= negative >> 8
		negative |= negative >> 4
		negative |= negative >> 2
		negative |= negative >> 1
		carry += negative & 256 // +=256 if negative, unmodified otherwise
		r[i] = byte(carry)
		// carry for next iteration
		carry = negative & (-1) // -1 if negative, 0 otherwise
	}
}

func (p *ExtendedGroupElement) FromParityAndY(bit byte, y *FieldElement) bool {
	var u, v, v3, vxx, check FieldElement

	FeCopy(&p.Y, y)
	FeOne(&p.Z)
	FeSquare(&u, &p.Y)
	FeMul(&v, &u, &d)
	FeSub(&u, &u, &p.Z) // y = y^2-1
	FeAdd(&v, &v, &p.Z) // v = dy^2+1

	FeSquare(&v3, &v)
	FeMul(&v3, &v3, &v) // v3 = v^3
	FeSquare(&p.X, &v3)
	FeMul(&p.X, &p.X, &v)
	FeMul(&p.X, &p.X, &u) // x = uv^7

	fePow22523(&p.X, &p.X) // x = (uv^7)^((q-5)/8)
	FeMul(&p.X, &p.X, &v3)
	FeMul(&p.X, &p.X, &u) // x = uv^3(uv^7)^((q-5)/8)

	var tmpX, tmp2 [32]byte

	FeSquare(&vxx, &p.X)
	FeMul(&vxx, &vxx, &v)
	FeSub(&check, &vxx, &u) // vx^2-u
	if FeIsNonZero(&check) == 1 {
		FeAdd(&check, &vxx, &u) // vx^2+u
		if FeIsNonZero(&check) == 1 {
			return false
		}
		FeMul(&p.X, &p.X, &SqrtM1)

		FeToBytes(&tmpX, &p.X)
		for i, v := range tmpX {
			tmp2[31-i] = v
		}
	}

	if FeIsNegative(&p.X) != bit {
		FeNeg(&p.X, &p.X)
	}

	FeMul(&p.T, &p.X, &p.Y)
	return true
}
